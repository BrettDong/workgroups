# Callgraph

This repository is a collection of tools for analyzing callgraphs. The tools have been developed mainly to target Linux Kernel, but they should work with any C target programs.

## Getting Started
These setup instructions have been tested on Ubuntu 18.04.

Checkout callgraph:
```
git clone https://github.com/elisa-tech/workgroups.git

# $CG_DIR contains the path to callgraph-tool
CG_DIR=$(pwd)/workgroups/safety-architecture/tools/callgraph-tool
```

Install the following requirements:
```
sudo apt install python3 python3-pip build-essential cmake libstdc++-8-dev
```

In addition, the scripts rely on python packages specified in requirements.txt. You can install the required packages with:
```
pip3 install -r requirements.txt
```

You also need the target kernel source tree. For the sake of example, we use the mainline tree:
```
git clone https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git

# We assume $KERNEL contains the path to the target kernel tree root
KERNEL=$(pwd)/linux
```

## Generating callgraph database
To make use of the tool, you first need to generate callgraph database relevant for your kernel source tree and build configuration.

#### Download Clang
```
cd $CG_DIR
./clang_download.py --out ./clang
```

#### Build the crix-callgraph tool
We are going to use crix-callgraph to build the callgraph database. Crix-callgraph is based on the callgraph code from the [crix](https://github.com/umnsec/crix) program. The tool was build on top of crix version: https://github.com/umnsec/crix/commit/13d3e5574aaaae07d93ae5d1fc5f46c9487992ba.

To compile crix-callgraph, run:
```
cd $CG_DIR

# Make sure correct version of clang is in $PATH
source $CG_DIR/env_wllvm.sh

# Build crix-callgraph
make

# Now, you can find the executable in `build/lib/crix-callgraph`
```

#### Generate bitcode files from the target program
The target program should be compiled with the same version of LLVM you built the crix-callgraph with. Also note that crix-callgraph requires the target code compiled with debug information included (-g). For the kernel build, you can enable debug information by setting CONFIG_DEBUG_INFO=y in the build configuration.

For convenience, we use the [wllvm](https://github.com/travitch/whole-program-llvm) to generate the LLVM bitcode files from the target kernel. [wllvm](https://github.com/travitch/whole-program-llvm) is available as a pip package: `pip3 install wllvm`.

```
cd $KERNEL

# Set the environment variables for wllvm
source $CG_DIR/env_wllvm.sh

# Clean
make clean && make mrproper
# Clean the generated bitcode files manually
find . -type f -name ".*.bc" -delete

# Generate defconfig
make defconfig CC=wllvm

# Manually enable CONFIG_DEBUG_INFO by editing the .config
vim .config

# Set any missing configuration options to default without prompting
make olddefconfig CC=wllvm

# Build the kernel generating bitcode files
make CC=wllvm HOSTCC=wllvm -j$(nproc)

# List all generated bitcode files
find ~+ -type f -name ".*.bc" > bitcodefiles.txt
```

#### Run the crix-callgraph tool
```
cd $CG_DIR

# To generate a callgraph database using the .bc files listed in
# $KERNEL/bitcodefiles.txt as input, run crix-callgraph as follows
# (the @-notation that allows specifying a list of input .bc files)
./build/lib/crix-callgraph @$KERNEL/bitcodefiles.txt

# Now, you can find the callgraph.csv database in `callgraph.csv`
```

Notice that we intentionally don't use the whole-program LLVM bitcode generated by wllvm. Instead, we use the list of individual pre-linked bitcode files as an input to crix-callgraph. On linking, llvm applies optimizations such as merging structurally identical struct types into one struct to avoid duplication. Such struct type merging would make MLTA used by crix-callgraph to identify indirect call targets less accurate, therefore, we use the pre-linked bitcode files.

## Visualizing callgraphs
Once the database is generated, it can be used to visualize function callgraphs.

As an example, to query callgraph starting from function syscall open (`__x64_sys_open`) with max depth of four function calls, you would run:
```
cd $CG_DIR
./graph_callgraph.py --csv callgraph.csv --caller_function_regex '^__x64_sys_close$' --depth 4
```
Which outputs the callgraph as an image:
<img src=sys_close.png width="900">

Notice the compiler optimizations and function inlining impact the output generated by crix-callgraph. Therefore, depending on the compiler options you used on building the target program, the output callgraphs might not be an exact representation of what one might expect based on the C-source files. For instructions on how to disable compiler optimizations and function inlining while building the kernel bitcode files, see TODO.
